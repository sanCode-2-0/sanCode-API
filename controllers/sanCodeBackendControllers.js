//   ______               __      __                                     _______             __
//   /      \             |  \    |  \                                   |       \           |  \
//  |  $$$$$$\ __    __  _| $$_   | $$____    ______    ______  __       | $$$$$$$\  ______   \$$  ______   ______ ____    ______    ______
//  | $$__| $$|  \  |  \|   $$ \  | $$    \  /      \  /      \|  \      | $$__/ $$ /      \ |  \ /      \ |      \    \  |      \  /      \
//  | $$    $$| $$  | $$ \$$$$$$  | $$$$$$$\|  $$$$$$\|  $$$$$$\\$$      | $$    $$|  $$$$$$\| $$|  $$$$$$\| $$$$$$\$$$$\  \$$$$$$\|  $$$$$$\
//  | $$$$$$$$| $$  | $$  | $$ __ | $$  | $$| $$  | $$| $$   \$$__       | $$$$$$$\| $$   \$$| $$| $$  | $$| $$ | $$ | $$ /      $$| $$   \$$
//  | $$  | $$| $$__/ $$  | $$|  \| $$  | $$| $$__/ $$| $$     |  \      | $$__/ $$| $$      | $$| $$__/ $$| $$ | $$ | $$|  $$$$$$$| $$
//  | $$  | $$ \$$    $$   \$$  $$| $$  | $$ \$$    $$| $$      \$$      | $$    $$| $$      | $$ \$$    $$| $$ | $$ | $$ \$$    $$| $$
//   \$$   \$$  \$$$$$$     \$$$$  \$$   \$$  \$$$$$$  \$$                \$$$$$$$  \$$       \$$  \$$$$$$  \$$  \$$  \$$  \$$$$$$$ \$$

//    ______   __    __      __    __            __                  __         __      __                                    __   __          __    __      __                  __                                                   __                          __                    __                  __
//   /      \ |  \  |  \    |  \  |  \          |  \                |  \       |  \    |  \                                  /  \ /  \        |  \  |  \    |  \                |  \                                                 /  \                        |  \                  |  \                |  \
//  |  $$$$$$\ \$$ _| $$_   | $$  | $$ __    __ | $$____   __       | $$____  _| $$_  _| $$_     ______    _______  __      /  $$/  $$______   \$$ _| $$_   | $$____   __    __ | $$____       _______   ______   ______ ____       /  $$_______   ______    ____| $$  ______          | $$____    ______   \$$  ______   ______ ____    ______    ______
//  | $$ __\$$|  \|   $$ \  | $$__| $$|  \  |  \| $$    \ |  \      | $$    \|   $$ \|   $$ \   /      \  /       \|  \    /  $$/  $$/      \ |  \|   $$ \  | $$    \ |  \  |  \| $$    \     /       \ /      \ |      \    \     /  $$/       \ /      \  /      $$ /      \  ______ | $$    \  /      \ |  \ /      \ |      \    \  |      \  /      \
//  | $$|    \| $$ \$$$$$$  | $$    $$| $$  | $$| $$$$$$$\ \$$      | $$$$$$$\\$$$$$$ \$$$$$$  |  $$$$$$\|  $$$$$$$ \$$   /  $$/  $$|  $$$$$$\| $$ \$$$$$$  | $$$$$$$\| $$  | $$| $$$$$$$\   |  $$$$$$$|  $$$$$$\| $$$$$$\$$$$\   /  $$|  $$$$$$$|  $$$$$$\|  $$$$$$$|  $$$$$$\|      \| $$$$$$$\|  $$$$$$\| $$|  $$$$$$\| $$$$$$\$$$$\  \$$$$$$\|  $$$$$$\
//  | $$ \$$$$| $$  | $$ __ | $$$$$$$$| $$  | $$| $$  | $$ __       | $$  | $$ | $$ __ | $$ __ | $$  | $$ \$$    \  __   /  $$/  $$ | $$  | $$| $$  | $$ __ | $$  | $$| $$  | $$| $$  | $$   | $$      | $$  | $$| $$ | $$ | $$  /  $$ | $$      | $$  | $$| $$  | $$| $$    $$ \$$$$$$| $$  | $$| $$   \$$| $$| $$  | $$| $$ | $$ | $$ /      $$| $$   \$$
//  | $$__| $$| $$  | $$|  \| $$  | $$| $$__/ $$| $$__/ $$|  \      | $$  | $$ | $$|  \| $$|  \| $$__/ $$ _\$$$$$$\|  \ /  $$/  $$  | $$__| $$| $$  | $$|  \| $$  | $$| $$__/ $$| $$__/ $$ __| $$_____ | $$__/ $$| $$ | $$ | $$ /  $$  | $$_____ | $$__/ $$| $$__| $$| $$$$$$$$        | $$__/ $$| $$      | $$| $$__/ $$| $$ | $$ | $$|  $$$$$$$| $$
//   \$$    $$| $$   \$$  $$| $$  | $$ \$$    $$| $$    $$ \$$      | $$  | $$  \$$  $$ \$$  $$| $$    $$|       $$ \$$|  $$|  $$    \$$    $$| $$   \$$  $$| $$  | $$ \$$    $$| $$    $$|  \\$$     \ \$$    $$| $$ | $$ | $$|  $$    \$$     \ \$$    $$ \$$    $$ \$$     \        | $$    $$| $$      | $$ \$$    $$| $$ | $$ | $$ \$$    $$| $$
//    \$$$$$$  \$$    \$$$$  \$$   \$$  \$$$$$$  \$$$$$$$            \$$   \$$   \$$$$   \$$$$ | $$$$$$$  \$$$$$$$      \$$  \$$     _\$$$$$$$ \$$    \$$$$  \$$   \$$  \$$$$$$  \$$$$$$$  \$$ \$$$$$$$  \$$$$$$  \$$  \$$  \$$ \$$      \$$$$$$$  \$$$$$$   \$$$$$$$  \$$$$$$$         \$$$$$$$  \$$       \$$  \$$$$$$  \$$  \$$  \$$  \$$$$$$$ \$$
//                                                                                             | $$                                 |  \__| $$
//                                                                                             | $$                                  \$$    $$
//                                                                                              \$$                                   \$$$$$$
//   _______                                                     __                                               ______                   __
//  |       \                                                   |  \                                             /      \                 |  \
//  | $$$$$$$\  ______    ______       __   ______    _______  _| $$_    __         _______   ______   _______  |  $$$$$$\  ______    ____| $$  ______
//  | $$__/ $$ /      \  /      \     |  \ /      \  /       \|   $$ \  |  \       /       \ |      \ |       \ | $$   \$$ /      \  /      $$ /      \
//  | $$    $$|  $$$$$$\|  $$$$$$\     \$$|  $$$$$$\|  $$$$$$$ \$$$$$$   \$$      |  $$$$$$$  \$$$$$$\| $$$$$$$\| $$      |  $$$$$$\|  $$$$$$$|  $$$$$$\
//  | $$$$$$$ | $$   \$$| $$  | $$    |  \| $$    $$| $$        | $$ __  __        \$$    \  /      $$| $$  | $$| $$   __ | $$  | $$| $$  | $$| $$    $$
//  | $$      | $$      | $$__/ $$    | $$| $$$$$$$$| $$_____   | $$|  \|  \       _\$$$$$$\|  $$$$$$$| $$  | $$| $$__/  \| $$__/ $$| $$__| $$| $$$$$$$$
//  | $$      | $$       \$$    $$    | $$ \$$     \ \$$     \   \$$  $$ \$$      |       $$ \$$    $$| $$  | $$ \$$    $$ \$$    $$ \$$    $$ \$$     \
//   \$$       \$$        \$$$$$$__   | $$  \$$$$$$$  \$$$$$$$    \$$$$            \$$$$$$$   \$$$$$$$ \$$   \$$  \$$$$$$   \$$$$$$   \$$$$$$$  \$$$$$$$
//                              |  \__/ $$
//                               \$$    $$
//                                \$$$$$$
//   _______              __                          ________              __        ________              __         ______    ______    ______   __    __
//  |       \            |  \                        |        \            /  \      |        \            /  \       /      \  /      \  /      \ |  \  |  \
//  | $$$$$$$\  ______  _| $$_     ______   __        \$$$$$$$$           /  $$       \$$$$$$$$           /  $$      |  $$$$$$\|  $$$$$$\|  $$$$$$\| $$  | $$
//  | $$  | $$ |      \|   $$ \   /      \ |  \          /  $$           /  $$           /  $$           /  $$        \$$__| $$| $$$\| $$ \$$__| $$| $$__| $$
//  | $$  | $$  \$$$$$$\\$$$$$$  |  $$$$$$\ \$$         /  $$           /  $$           /  $$           /  $$         /      $$| $$$$\ $$ /      $$| $$    $$
//  | $$  | $$ /      $$ | $$ __ | $$    $$ __         /  $$           /  $$           /  $$           /  $$         |  $$$$$$ | $$\$$\$$|  $$$$$$  \$$$$$$$$
//  | $$__/ $$|  $$$$$$$ | $$|  \| $$$$$$$$|  \       /  $$           /  $$           /  $$           /  $$          | $$_____ | $$_\$$$$| $$_____       | $$
//  | $$    $$ \$$    $$  \$$  $$ \$$     \ \$$      |  $$           |  $$           |  $$           |  $$           | $$     \ \$$  \$$$| $$     \      | $$
//   \$$$$$$$   \$$$$$$$   \$$$$   \$$$$$$$           \$$             \$$             \$$             \$$             \$$$$$$$$  \$$$$$$  \$$$$$$$$       \$$

const { validationResult, check } = require("express-validator");
const express = require("express");
const app = express();
const cors = require("cors");
const excelJS = require("exceljs");
const moment = require("moment-timezone");
const pkg = require("body-parser");
const { json: _json } = pkg;
const loadData = require("../assets/ailmentsChecked.js");

app.use(cors());
app.use(express.json());
app.use(_json());

// Start of today date
const startOfToday = moment().startOf("day");
// End of today date
const endOfToday = moment().endOf("day");

const {
  db,
  staffTableName,
  studentTableName,
  reportTableName,
} = require("../config/database.js");

const { KEYS } = require("../config/keys.js");
const { supabase } = require("../config/supabase/config.js");
const { dev_mode } = require("../dev_mode.js");

// Return name of the API if requested
const defaultResponse = async (req, res) => {
  res.status(200).send({
    status: 200,
    message: "Make requests to the san-code API",
  });
};

module.exports = { startOfToday, defaultResponse };

// Import the validation library

//Endpoint to validate that student exists in the database
const getStudentByAdmissionNumber = async (req, res) => {
  const admissionNumber = Number(req.params.admissionNumber);

  // Validate admissionNumber input
  const validationRules = [
    // Rule to check if admissionNumber is a number
    check("admissionNumber")
      .isNumeric()
      .withMessage("Invalid admission number"),
  ];

  // Validate the input
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  // Select table
  // SQLITE
  // db.get(
  //   `SELECT * FROM ${studentTableName} WHERE admNo=?`,
  //   [admissionNumber],
  //   (err, rows) => {
  //     if (err) {
  //       // Log the error to a file
  //       console.error(err);
  //       // Send generic response for database disconnection error
  //       res
  //         .status(500)
  //         .json({ error: "An error occurred. Please try again later" });
  //       return;
  //     }
  //     if (!rows || rows.length === 0) {
  //       res.status(404).json({ error: "Student not found" });
  //       return;
  //     }
  //     res.json(rows);
  //   }
  // );
  // SUPABASE
  const { data, error } = await supabase
    .from(studentTableName)
    .select("*")
    .eq("admNo", admissionNumber);
  if (error) {
    console.error(error);
    res
      .status(500)
      .json({ error: "An error occurred. Please try again later" });
    return;
  }
  if (!data || data.length === 0) {
    res.status(404).json({ error: "Student not found" });
    return;
  }
  //Selecting the first record in the data array to prevent returning an array and prevent returning duplicate records
  res.json(data[0]);
};

// Fetch Students History
const getStudentHistory = async (req, res) => {
  const admNo = parseInt(req.params.admNo);

  // Implemented By Functions And Procudures - Really Simple and Efficient Implementation
  const { data, error } = await supabase.rpc("get_student_history", {
    student_admno: admNo,
  });

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.json(data);
};

// Endpoint to get students going to the hospital
const getStudentsGoingToHospital = async (req, res) => {
  // SQLITE
  // db.all(
  //   `SELECT * FROM ${studentTableName} WHERE going_to_hospital=?`,
  //   [1],
  //   (err, rows) => {
  //     if (err) {
  //       console.error(err);
  //       res
  //         .status(500)
  //         .json({ error: "An error occurred. Please try again later" });
  //       return;
  //     }

  //     if (!rows || rows.length === 0) {
  //       res.status(404).json({ error: "No student data" });
  //       return;
  //     }

  //     res.json(rows);
  //   }
  // );

  // SUPABASE
  const { data, error } = await supabase
    .from(studentTableName)
    .select("*")
    .eq("going_to_hospital", 1);
  if (error) {
    console.error(error);
    res
      .status(500)
      .json({ error: "An error occurred. Please try again later" });
    return;
  }
  if (!data || data.length === 0) {
    res.status(404).json({ error: "No student data" });
    return;
  }
  res.json(data);
};

// Endpoint to accept data from the full entry submission
const studentFullEntry = async (req, res) => {
  /*
   * FLOW
   * Check if request body exists and is not null.
   * Destructure the required properties from the request body.
   * Check if any properties are missing in the input data
   * If any required property is missing, send back a 404 status code with an error message.
   * If all required properties are present, update the record in the db using the db.run method.
   * The SQL query updates the record in the studentTableName table with the provided data and the current timestamp.
   * If an error occurs during the update, send a response with a 500 status code and an error message.
   * If the update is successful, send a response with a success message and the current timestamp.
   */
  try {
    if (req?.body !== null && req?.body !== undefined) {
      const {
        studentAdmNo,
        tempReading,
        complain,
        ailment,
        medication,
        going_to_hospital,
      } = req.body;

      //Validate input data
      if (
        !studentAdmNo ||
        !tempReading ||
        !complain ||
        !ailment ||
        !medication ||
        going_to_hospital == undefined
      ) {
        res.status(400).json({ error: "Invalid input data" });
        return;
      }
      // Timestamp
      // const timestamp = moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss");

      // SQLITE
      // Update record where student admno matches studentAdmNo
      // const query = `UPDATE ${studentTableName} SET tempReading=?, complain=?, ailment=?, medication=?, going_to_hospital=?, timestamp=? WHERE admNo=?`;
      // const values = [
      //   tempReading,
      //   complain,
      //   ailment,
      //   medication,
      //   going_to_hospital ? 1 : 0,
      //   moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss"),
      //   studentAdmNo,
      // ];
      // //Regular function is used instead of arrow function to be able to access `this` within the function
      // db.run(query, values, function (error) {
      //   if (error) {
      //     // console.error(error.message);
      //     res
      //       .status(500)
      //       .send("An error occurred while processing the request.");
      //   } else {
      //     //Should only return if rows are updated
      //     if (this.changes === 0) {
      //       res.status(204).send("No rows were updated.");
      //     } else {
      //       //Status 200 - Success
      //       res.status(200).json({
      //         status: 200,
      //         message: `Record updated for ${studentAdmNo} successfully. ${new Date()
      //           .toISOString()
      //           .replace(/T\d{2}:\d{2}:\d{2}\.\d{3}Z/g, "")} `,
      //       });
      //     }
      //   }
      // });

      // SUPABASE
      const going_to_hospital_value = going_to_hospital ? 1 : 0;
      const { data, error } = await supabase
        .from(studentTableName)
        .update({
          tempReading,
          complain,
          ailment,
          medication,
          going_to_hospital: going_to_hospital_value,
          timestamp: moment()
            .tz("Africa/Nairobi")
            .format("YYYY-MM-DD HH:mm:ss"),
        })
        .eq("admNo", studentAdmNo)
        .select();
      if (error) {
        console.error(error);
        res
          .status(500)
          .json({ error: "An error occurred. Please try again later" });
        return;
      }
      if (!data || data.length === 0) {
        res.status(404).json({ error: "Student not found" });
        return;
      }
      res.json({
        status: 200,
        message: `Record updated for ${studentAdmNo} successfully. ${new Date()
          .toISOString()
          .replace(/T\d{2}:\d{2}:\d{2}\.\d{3}Z/g, "")}`,
      });
    }
  } catch (error) {
    res.status(400).json({ error: "Invalid request body" });
  }
};

// Endpoint to accept data from the quick update submission
const studentQuickUpdate = async (req, res) => {
  const { studentAdmNo, tempReading, complain, medication, going_to_hospital } =
    req.body;

  //Validate input
  if (
    !studentAdmNo ||
    !tempReading ||
    !complain ||
    !medication ||
    going_to_hospital == undefined
  ) {
    res.status(400).json({ error: "Invalid input data" });
    return;
  }
  // Timestamp
  // const timestamp = moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss");

  // SQLITE
  // Update record where student admission number matches studentAdmNo
  // db.run(
  //   `UPDATE ${studentTableName} SET tempReading =?, complain =?, ailment=?, going_to_hospital=?, timestamp =? WHERE admNo =? `,
  //   [
  //     tempReading,
  //     complain,
  //     ailment,
  //     going_to_hospital ? 1 : 0,
  //     moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss"),
  //     studentAdmNo,
  //   ],
  //   (error) => {
  //     if (error) {
  //       //Log error.message
  //       res
  //         .status(500)
  //         .send({ error: "An error occured while updating the record." });
  //     } else {
  //       res.status(200).json({
  //         status: 200,
  //         message: `Record updated for ${studentAdmNo} successfully.`,
  //       });
  //     }
  //   }
  // );

  // SUPABASE
  const going_to_hospital_value = going_to_hospital ? 1 : 0;
  const { data, error } = await supabase
    .from(studentTableName)
    .update({
      tempReading,
      complain,
      medication,
      going_to_hospital: going_to_hospital_value,
      timestamp: moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss"),
    })
    .eq("admNo", studentAdmNo)
    .select();
  if (error) {
    console.error(error);
    res
      .status(500)
      .json({ error: "An error occurred. Please try again later" });
    return;
  }
  if (!data || data.length === 0) {
    res.status(404).json({ error: "Student not found" });
    return;
  }
  res.json({
    status: 200,
    message: `Record updated for ${studentAdmNo} successfully.`,
  });
};

//Endpoint to create a new record for a student
const createStudentRecord = async (req, res) => {
  const { admNo, fName, sName, class: className } = req.body;

  //Validate input
  if (!admNo || !fName || !sName || !className) {
    res.status(400).json({ error: "Invalid input data" });
    return;
  }

  // SUPABASE
  // Account for the case where the record already exists
  const { data, error } = await supabase
    .from(studentTableName)
    .select("*")
    .eq("admNo", admNo);

  if (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
    return;
  }

  if (data.length > 0) {
    res.status(409).json({ error: "Student record already exists" });
    return;
  }

  // Insert a new record for the student
  const { data: newData, error: newError } = await supabase
    .from(studentTableName)
    .insert([{ admNo, fName, sName, class: className }]);

  if (newError) {
    console.error(newError);
    res.status(500).send({ error: "Internal Server Error" });
    return;
  }

  res.status(200).json({
    status: 200,
    message: `Entry created successfully for ${admNo}`,
    admNo,
    fName,
  });
};

// Endpoint to edit a student record for a student
const updateStudentRecord = async (req, res) => {
  const { admNo, fName, sName, class: className } = req.body;

  //Validate input
  if (!admNo || !fName || !sName || !className) {
    res.status(400).json({ error: "Invalid input data" });
    return;
  }

  // SUPABASE
  // Update the record for the student
  const { data, error } = await supabase
    .from(studentTableName)
    .update({ fName, sName, class: className })
    .eq("admNo", admNo)
    .select();

  if (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
    return;
  }

  res.status(200).json({
    status: 200,
    message: `Record updated successfully for ${admNo}`,
    admNo,
    fName,
  });
};

//Endpoint to validate that staff exists in the database
const getStaffMemberByID = async (req, res) => {
  let idNo = req.params.idNo;

  // Select all from staff table
  // SQLITE
  // db.all(
  //   `SELECT * FROM ${staffTableName} WHERE idNo = ${idNo} `,
  //   [],
  //   (err, rows) => {
  //     if (err) {
  //       console.error(err.message);
  //     }
  //     res.json(rows);
  //   }
  // );

  // SUPABASE
  const { data, error } = await supabase
    .from(staffTableName)
    .select("*")
    .eq("idNo", idNo);

  if (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
    return;
  }

  res.status(200).json(data);
};

// Endopoint to fetch staff member's history
const getStaffHistory = async (req, res) => {
  let idNo = parseInt(req.params.idNo);

  const { data, error } = await supabase.rpc("get_staff_history", {
    staff_idno: idNo,
  });

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.json(data);
};

//Endpoint to create a record for a staff member
const createStaffRecord = async (req, res) => {
  const { idNo, fName, sName } = req.body;

  //Insert a new record for the staff members
  // SQLITE
  // db.run(
  //   `INSERT INTO ${staffTableName} (idNo, fName, sName) VALUES(?,?,?)`,
  //   [idNo, fName, sName],
  //   (error) => {
  //     if (error) {
  //       res.status(500).send(`Error creating the entry for ${fName}`);
  //     } else {
  //       res.status(200).send({
  //         status: 200,
  //         message: "Entry created successfully",
  //         idNo: idNo,
  //         fName: fName,
  //       });
  //     }
  //   }
  // );

  // SUPABASE
  const { data, error } = await supabase
    .from(staffTableName)
    .insert([{ idNo: Number(idNo), fName, sName }]);

  if (error) {
    console.error(error);
    res.status(500).send({ error: "Internal Server Error" });
    return;
  }

  res.status(200).json({
    status: 200,
    message: `Entry created successfully for ${fName}`,
    idNo,
    fName,
  });
};

// Endpoint to accept data from the full entry submission for a staff member
const staffFullEntry = async (req, res) => {
  const { idNo, tempReading, complain, ailment, medication } = req.body;

  // Timestamp
  // const timestamp = moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss");

  // Update record where staff Kenyan id No matches idNo
  // SQLITE
  // db.run(
  //   `UPDATE ${staffTableName} SET tempReading =?, complain =?, ailment =?, medication =?, timestamp =? WHERE idNo =? `,
  //   [
  //     tempReading,
  //     complain,
  //     ailment,
  //     medication,
  //     moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss"),
  //     idNo,
  //   ],
  //   (error) => {
  //     if (error) {
  //       res.status(500).send("Error updating the record.");
  //     } else {
  //       res
  //         .status(200)
  //         .send({ message: `Record updated for ${idNo} successfully.` });
  //     }
  //   }
  // );

  console.log(
    "idNo",
    idNo,
    "tempReading",
    tempReading,
    "complain",
    complain,
    "ailment",
    ailment,
    "medication",
    medication
  );

  // SUPABASE
  const { data, error } = await supabase
    .from(staffTableName)
    .update({
      tempReading,
      complain,
      ailment,
      medication,
      timestamp: moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss"),
    })
    .eq("idNo", idNo)
    .select();

  if (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
    return;
  }

  res.status(200).json({
    message: `Record updated for ${idNo} successfully.`,
  });
};

// Endpoint to accept data from the quick update submission for a staff member
const staffQuickUpdate = async (req, res) => {
  const { idNo, tempReading, complain, medication } = req.body;

  // Timestamp
  // const timestamp = moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss");

  // Update record where staff idNo matches idNo
  // SQLITE
  // db.run(
  //   `UPDATE ${staffTableName} SET tempReading =?, complain=?, ailment=?, timestamp =? WHERE idNo =? `,
  //   [
  //     tempReading,
  //     complain,
  //     ailment,
  //     moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss"),
  //     idNo,
  //   ],
  //   (error) => {
  //     if (error) {
  //       res.status(500).send(`Error updating the record.Message : ${error} `);
  //     } else {
  //       res
  //         .status(200)
  //         .send({ message: `Record updated for ${idNo} successfully.` });
  //     }
  //   }
  // );

  // SUPABASE
  const { data, error } = await supabase
    .from(staffTableName)
    .update({
      tempReading,
      complain,
      medication,
      timestamp: moment().tz("Africa/Nairobi").format("YYYY-MM-DD HH:mm:ss"),
    })
    .eq("idNo", idNo)
    .select();

  if (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
    return;
  }

  res.status(200).json({
    message: `Record updated for ${idNo} successfully.`,
  });
};

// Endpoint to fetch this week's student data for purposes of the nurse filtering
const getStudentData = async (req, res) => {
  // Select all of this week's student data
  // timestamp : 2024-07-04 22:54:33

  // SQLITE
  // db.all(
  //   `SELECT * FROM ${studentTableName} WHERE timestamp >= ? AND ailment != "" ORDER BY timestamp DESC`,
  //   [moment().subtract(7, "days").format("YYYY-MM-DD HH:mm:ss")],
  //   (err, rows) => {
  //     if (err) {
  //       console.error(err.message);
  //       res.status(500).send("Internal Server Error");
  //       return;
  //     }

  //     const data = rows.map((row) => {
  //       const obj = {};
  //       Object.keys(row).forEach((key) => {
  //         // Remove if ailment and medication are empty
  //         obj[key] = row[key];
  //         if (key === "ailment" && row[key] === "") {
  //           return;
  //         }
  //       });
  //       return obj;
  //     });

  //     res.json(data);
  //   }
  // );

  // SUPABASE
  const { data, error } = await supabase
    .from(studentTableName)
    .select("*")
    .gte(
      "timestamp",
      moment().subtract(80, "days").format("YYYY-MM-DD HH:mm:ss")
    )
    .neq("ailment", "")
    .order("timestamp", { ascending: false });
  if (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
    return;
  }
  res.json(data);
};

// Endpoint to fetch today's staff data for purposes of the nurse filtering
const getStaffData = async (req, res) => {
  // SQLITE
  // db.all(
  //   `SELECT * FROM ${staffTableName} WHERE timestamp >= ? AND ailment != "" ORDER BY timestamp DESC`,
  //   [moment().subtract(7, "days").format("YYYY-MM-DD HH:mm:ss")],
  //   (err, rows) => {
  //     if (err) {
  //       console.error(err.message);
  //       res.status(500).send("Internal Server Error");
  //       return;
  //     }

  //     const data = rows.map((row) => {
  //       const obj = {};
  //       Object.keys(row).forEach((key) => {
  //         // Remove if ailment and medication are empty
  //         obj[key] = row[key];
  //         if (key === "ailment" && row[key] === "") {
  //           return;
  //         }
  //       });
  //       return obj;
  //     });

  //     res.json(data);
  //   }
  // );

  // SUPABASE
  const { data, error } = await supabase
    .from(staffTableName)
    .select("*")
    .gte(
      "timestamp",
      moment().subtract(80, "days").format("YYYY-MM-DD HH:mm:ss")
    )
    .neq("ailment", "")
    .order("timestamp", { ascending: false });

  if (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
    return;
  }

  res.status(200).json(data);
};

// Endpoint to update report data
const updateReport = async (req, res) => {
  const updateReportTable = async () => {
    const numberOfDaysSinceStartOfThisMonth = moment()
      .startOf("month")
      .format("YYYY-MM-DD HH:mm:ss");

    const { data: staffRecords, error: staffError } = await supabase
      .from(staffTableName)
      .select("*")
      .gte("timestamp", numberOfDaysSinceStartOfThisMonth);

    const { data: studentRecords, error: studentError } = await supabase
      .from(studentTableName)
      .select("*")
      .gte("timestamp", numberOfDaysSinceStartOfThisMonth);

    if (staffError || studentError) {
      console.error("Error fetching records:", staffError || studentError);
      throw new Error("Error fetching records");
    }

    const rows = [...staffRecords, ...studentRecords];

    const groupRecordsByDay = rows.reduce((acc, record) => {
      const date = moment(record.timestamp).date();

      if (!acc[date]) {
        acc[date] = [];
      }

      acc[date].push(record);

      return acc;
    }, {});

    dev_mode && console.log("groupRecordsByDay", groupRecordsByDay);

    const groupAilmentTotalNumbersByDay = Object.keys(groupRecordsByDay).reduce(
      (acc, day) => {
        acc[day] = groupRecordsByDay[day].reduce((acc, record) => {
          const { ailment } = record;

          if (!acc[ailment]) {
            acc[ailment] = 1;
          } else {
            acc[ailment]++;
          }

          return acc;
        }, {});

        return acc;
      },
      {}
    );

    // Calculate groupFirstAttendanceNumbersByDay
    const groupFirstAttendanceNumbersByDay = Object.keys(
      groupRecordsByDay
    ).reduce((acc, day) => {
      acc[day] = groupRecordsByDay[day].reduce((innerAcc, record) => {
        const { timestamp } = record;
        const recordDate = new Date(timestamp).toDateString();
        const todayDate = new Date().toDateString();

        if (recordDate !== todayDate) {
          innerAcc += 1;
        }

        return innerAcc;
      }, 0); // Initialize innerAcc to 0
      return acc;
    }, {});

    // Calculate groupReAttendanceNumbersByDay
    const groupReAttendanceNumbersByDay = Object.keys(groupRecordsByDay).reduce(
      (acc, day) => {
        acc[day] = groupRecordsByDay[day].reduce((innerAcc, record) => {
          const { timestamp } = record;
          const recordDate = new Date(timestamp).toDateString();
          const todayDate = new Date().toDateString();

          if (recordDate === todayDate) {
            innerAcc += 1;
          }

          return innerAcc;
        }, 0); // Initialize innerAcc to 0
        return acc;
      },
      {}
    );

    // Calculate groupReferralsByDay
    const groupReferralsByDay = Object.keys(groupRecordsByDay).reduce(
      (acc, day) => {
        acc[day] = groupRecordsByDay[day].reduce((innerAcc, record) => {
          const { timestamp, going_to_hospital } = record;
          const recordDate = new Date(timestamp).toDateString();
          const todayDate = new Date().toDateString();

          if (recordDate === todayDate && going_to_hospital === 1) {
            innerAcc += 1;
          }

          return innerAcc;
        }, 0); // Initialize innerAcc to 0
        return acc;
      },
      {}
    );

    dev_mode && console.log(groupFirstAttendanceNumbersByDay);
    dev_mode && console.log(groupReAttendanceNumbersByDay);
    dev_mode && console.log(groupReferralsByDay);

    // Merge groupFirstAttendanceNumbersByDay into groupAilmentTotalNumbersByDay
    Object.keys(groupFirstAttendanceNumbersByDay).forEach((day) => {
      const firstAttendanceCount = groupFirstAttendanceNumbersByDay[day];
      if (!groupAilmentTotalNumbersByDay[day]) {
        groupAilmentTotalNumbersByDay[day] = {};
      }
      groupAilmentTotalNumbersByDay[day]["NO. OF FIRST ATTENDANCES"] =
        firstAttendanceCount;
    });

    // Merge groupReAttendanceNumbersByDay into groupAilmentTotalNumbersByDay
    Object.keys(groupReAttendanceNumbersByDay).forEach((day) => {
      const reAttendanceCount = groupReAttendanceNumbersByDay[day];
      if (!groupAilmentTotalNumbersByDay[day]) {
        groupAilmentTotalNumbersByDay[day] = {};
      }
      groupAilmentTotalNumbersByDay[day]["RE-ATTENDANCES"] = reAttendanceCount;
    });

    // Merge groupReferralsByDay into groupAilmentTotalNumbersByDay
    Object.keys(groupReferralsByDay).forEach((day) => {
      const referralCount = groupReferralsByDay[day];
      if (!groupAilmentTotalNumbersByDay[day]) {
        groupAilmentTotalNumbersByDay[day] = {};
      }
      groupAilmentTotalNumbersByDay[day]["Referrals to other health facility"] =
        referralCount;
    });

    dev_mode &&
      console.log(
        "groupAilmentTotalNumbersByDay",
        groupAilmentTotalNumbersByDay
      );

    // Update report table with groupAilmentTotalNumbersByDay
    await Promise.all(
      Object.keys(groupAilmentTotalNumbersByDay).map(async (day, index) => {
        const totalNumbersByDay = Object.keys(
          groupAilmentTotalNumbersByDay[day]
        ).reduce((acc, ailment) => {
          acc[ailment] = groupAilmentTotalNumbersByDay[day][ailment];
          return acc;
        }, {});

        // totalNumbersByDay Example : { 'Upper Respiratory Tract Infections': 2, 'All Other Diseases': 1 }

        Object.keys(totalNumbersByDay).map(async (ailment, index) => {
          const count_per_ailment = totalNumbersByDay[ailment];

          const { error } = await supabase
            .from(reportTableName)
            .update({
              [`${day}`]: count_per_ailment,
            })
            .eq("disease", ailment);

          if (error) {
            console.error(
              `Error updating report for day ${day} and ailment ${ailment}:`,
              error.message
            );
            throw new Error(`Error updating report for day ${day}`);
          }
        });
      })
    );
  };

  const resetReportTable = async () => {
    const today = moment().date();
    const lastDayOfMonth = moment().endOf("month").date();

    try {
      for (let day = today; day <= lastDayOfMonth; day++) {
        const updateData = {
          [`${day}`]: 0,
        };

        // Perform update for each day using Supabase
        const { error } = await supabase
          .from(reportTableName)
          .update(updateData)
          .eq("disease" /*Every ailment in list*/);

        if (error) {
          console.error(
            `Error resetting report for day ${day}:`,
            error.message
          );
          throw new Error(`Error resetting report for day ${day}`);
        }
      }

      console.log("Report table reset successfully");
    } catch (error) {
      console.error("Error resetting report table:", error.message);
      throw new Error("Error resetting report table");
    }
  };

  await resetReportTable();

  await updateReportTable();

  res
    .status(200)
    .json({ status: 200, message: "Successfully updated the report" });
};

// Endpoint to generate excel
const generateExcel = async (req, res) => {
  // Select all records from both the students table and staff table
  // db.all(
  //   `SELECT staffRecordID AS recordID, idNo AS regNo, fName, sName, NULL AS tName, NULL AS fourthName, NULL AS class, tempReading, complain, ailment, medication, timestamp
  //   FROM ${staffTableName}
  //         UNION
  //   SELECT recordID, admNo AS regNo, fName, sName, tName, fourthName, class, tempReading, complain, ailment, medication, timestamp
  //   FROM ${studentTableName} `,
  //   [],
  //   async (err, rows) => {
  //     if (err) {
  //       console.error(err.message);
  //     }

  //     // Transform the rows to objects
  //     const data = rows.map((row) => {
  //       const obj = {};
  //       Object.keys(row).forEach((key) => {
  //         obj[key] = row[key];
  //       });
  //       return obj;
  //     });

  //     let filteredData = []; //Just like the data array but holds records whose date matches today's
  //     let dateToBeChecked;
  //     // Loop through the data array which holds the records as individual objects.
  //     for (
  //       let dataArrayLength = 0;
  //       dataArrayLength < data.length;
  //       dataArrayLength++
  //     ) {
  //       //Filter and only retrieve records whose timestamp matches to today's
  //       // Format the date to Moment.js format
  //       dateToBeChecked = moment(
  //         data[dataArrayLength].timestamp,
  //         "YYYY-MM-DD HH:mm:ss"
  //       );

  //       // If it falls between start of today and end of the day, spread it into the filteredData array
  //       // Since it will be handling a lot of data, using the spread operator is kind of effective
  //       if (dateToBeChecked.isBetween(startOfToday, endOfToday)) {
  //         filteredData = [...filteredData, data[dataArrayLength]];
  //       }
  //     }

  //     //Logic to insert `filteredData` into an excel file
  //     let fileName = moment().format("dddd, Do MMMM YYYY");
  //     fileName = fileName.replace(/ /g, "_").replace(/,/g, "");
  //     const workbook = new excelJS.Workbook(); // Create a new workbook
  //     const worksheet = workbook.addWorksheet(fileName);
  //     const path = `${KEYS.HOME} /Desktop/sanCode - Excel - Summaries`; //Path ( relative to the root folder ) to location where workbook will be saved.
  //     //Data Column names ( key should match column name in db )
  //     worksheet.columns = [
  //       { header: "Record ID", key: "recordID", width: 15 },
  //       { header: "Admission / ID Number", key: "regNo", width: 15 },
  //       { header: "First Name", key: "fName", width: 15 },
  //       { header: "Second Name", key: "sName", width: 15 },
  //       { header: "Third Name", key: "tName", width: 15 },
  //       { header: "Fourth Name", key: "fourthName", width: 15 },
  //       { header: "Student's Class", key: "class", width: 15 },
  //       { header: "Complain", key: "complain", width: 15 },
  //       { header: "Temperature Reading", key: "tempReading", width: 15 },
  //       { header: "Medication", key: "medication", width: 15 },
  //       { header: "Time Stamp", key: "timestamp", width: 15 },
  //     ];
  //     //Loop through data to add data into worksheet
  //     let counter = 1;
  //     filteredData.forEach((eachRecord) => {
  //       eachRecord.recordID = counter;
  //       worksheet.addRow(eachRecord);
  //       counter++;
  //     });

  //     //Bold the header row ( 1st row ) bold
  //     worksheet.getRow(1).eachCell((cell) => {
  //       cell.font = { bold: true };
  //       cell.alignment = { textRotation: 45 };
  //     });

  //     //A try catch block to generate excel file
  //     try {
  //       const excelData = await workbook.xlsx
  //         .writeFile(`${path} /${fileName}.xlsx`)
  //         .then(() => {
  //           res.download(`${path}/${fileName}.xlsx`, (error) => {
  //             if (error) {
  //               res.status(500).json({
  //                 error: 500,
  //                 message: "Error generating Excel file!",
  //               });
  //             }
  //           });
  //         });
  //     } catch (error) {
  //       res.send({
  //         status: "Error",
  //         message: "Something went wrong...",
  //       });
  //     }
  //   }
  // );

  // SUPABASE - Generate Excel File from Supabase data and send it back with res.download()
  const fileName = moment().format("dddd, Do MMMM YYYY").replace(/ /g, "_");
  const workbook = new excelJS.Workbook();
  const worksheet = workbook.addWorksheet(fileName);
  const path = `${KEYS.HOME}/Desktop/sanCode - Excel - Summaries`;

  // Data Column names ( key should match column name in db )
  worksheet.columns = [
    { header: "Record ID", key: "recordID", width: 15 },
    { header: "Admission / ID Number", key: "regNo", width: 15 },
    { header: "First Name", key: "fName", width: 15 },
    { header: "Second Name", key: "sName", width: 15 },
    { header: "Third Name", key: "tName", width: 15 },
    { header: "Fourth Name", key: "fourthName", width: 15 },
    { header: "Student's Class", key: "class", width: 15 },
    { header: "Complain", key: "complain", width: 15 },
    { header: "Temperature Reading", key: "tempReading", width: 15 },
    { header: "Medication", key: "medication", width: 15 },
    { header: "Date & Time", key: "timestamp", width: 15 },
  ];

  // Loop through data fetched from Supabase to add data into worksheet
  let counter = 1;
  const { data, error } = await supabase
    .from(studentTableName)
    .select("*")
    .gte("timestamp", startOfToday.format("YYYY-MM-DD HH:mm:ss"));

  if (error) {
    console.error(error);
    res.status(500).json({
      error: 500,
      message: "Error fetching data from the database",
    });
    return;
  }

  data.forEach((eachRecord) => {
    eachRecord.recordID = counter;
    worksheet.addRow(eachRecord);
    counter++;
  });

  // Bold the header row ( 1st row ) bold
  worksheet.getRow(1).eachCell((cell) => {
    cell.font = { bold: true };
    cell.alignment = { textRotation: 45 };
  });

  // Try catch block to generate excel file
  try {
    await workbook.xlsx.writeFile(`${path}/${fileName}.xlsx`);
    res.download(`${path}/${fileName}.xlsx`, (error) => {
      if (error) {
        res.status(500).json({
          error: 500,
          message: "Error generating Excel file!",
        });
      }
    });
  } catch (error) {
    res.send({
      status: "Error",
      message: "Something went wrong...",
    });
  }
};

// Endpoint to post new student details
const newStudents = async (req, res) => {
  // Binding to hold onto the array with student details
  // Convert string to array
  let arrayWithStudentDetails = req?.body?.body;
  arrayWithStudentDetails = JSON.parse(arrayWithStudentDetails);

  // Example
  // [["First Name","Second Name","Adm No.","Class"],["IBRAHIM","OITAYU","15586","1A"],["MAZURI","ABEL","15596","1A"],["NDEGWA","MICHAEL","15606","1A"],["MWANGI","OSTEEN","15616","1A"],["ODHIAMBO","VICTOR","15626","1A"],["MAX","KAINGU","15636","1A"],["KURIA","ROBERT","15646","1A"],["MWANGI","TAL","15656","1A"],["MUTUA","ELVIS","15666","1A"],["KYALO","STANLEY","15676","1A"],["DENNIS","ABRAHAM","15686","1A"],["MUGUNA","VICTOR","15696","1A"],["ABDULLAHI","HARUN","15706","1A"],["NGALANGE","HOLYFIELD","15716","1A"],["NOAH","MUTIE","15726","1A"],["KIMATHI","TRAVIS","15736","1A"],["RYAN","ODUMA","15746","1A"],

  // Check if the array is empty
  if (!arrayWithStudentDetails) {
    res.status(400).send({
      message: "No student details have been provided",
    });
    return;
  }

  // Check if the array is not an array
  if (!Array.isArray(arrayWithStudentDetails)) {
    console.log(typeof arrayWithStudentDetails);
    res.status(400).send({
      message: "Student details should be an array",
    });
    return;
  }

  // Check if the array is empty
  if (arrayWithStudentDetails.length === 0) {
    res.status(400).send({
      message: "No student details have been provided",
    });
    return;
  }

  // Check if the array has the correct number of columns
  if (arrayWithStudentDetails[0].length !== 4) {
    res.status(400).send({
      message: "Invalid number of columns in the student details",
    });
    return;
  }

  // Check if the array has the correct column names
  if (
    arrayWithStudentDetails[0][0] !== "First Name" ||
    arrayWithStudentDetails[0][1] !== "Second Name" ||
    arrayWithStudentDetails[0][2] !== "Adm No." ||
    arrayWithStudentDetails[0][3] !== "Class"
  ) {
    res.status(400).send({
      message: "Invalid column names in the student details",
    });
    return;
  }

  // SQLITE
  // Insert prepared statement
  // const insertQuery = `INSERT INTO ${studentTableName} (admNo, fName, sName, class) VALUES(?,?,?,?)`;
  // const selectQuery = `SELECT COUNT(*) as count FROM ${studentTableName} WHERE admNo=?`;

  // // Loop through the array and insert the records
  // for (let i = 1; i < arrayWithStudentDetails.length; i++) {
  //   const studentDetails = arrayWithStudentDetails[i];
  //   const admNo = studentDetails[2];
  //   const fName = studentDetails[0];
  //   const sName = studentDetails[1];
  //   const studentClass = studentDetails[3];

  //   // Check if the student exists
  //   const count = await new Promise((resolve, reject) => {
  //     db.get(selectQuery, [admNo], (err, row) => {
  //       if (err) {
  //         console.error(err.message);
  //         reject(err);
  //       }
  //       resolve(row.count);
  //     });
  //   });

  //   // If the student does not exist, insert the student
  //   if (count === 0) {
  //     db.run(insertQuery, [admNo, fName, sName, studentClass], (err) => {
  //       if (err) {
  //         console.error(err.message);
  //       }
  //     });
  //   }
  // }

  // SUPABASE
  // Loop through the array and insert the records
  for (let i = 1; i < arrayWithStudentDetails.length; i++) {
    const studentDetails = arrayWithStudentDetails[i];
    const admNo = studentDetails[2];
    const fName = studentDetails[0];
    const sName = studentDetails[1];
    const studentClass = studentDetails[3];

    // Check if the student exists
    const { data, error } = await supabase
      .from(studentTableName)
      .select("admNo")
      .eq("admNo", admNo);

    if (error) {
      console.error(error);
      res.status(500).send({
        message: "An error occurred while processing the request",
      });
      return;
    }

    // If the student does not exist, insert the student
    if (!data || data.length === 0) {
      const { error: insertError } = await supabase
        .from(studentTableName)
        .insert([{ admNo, fName, sName, class: studentClass }]);
      if (insertError) {
        console.error(insertError);
        res.status(500).send({
          message: "An error occurred while processing the request",
        });
      }
    }
  }

  res.status(200).send({
    message: "Student details have been successfully added",
  });
};

// Endpoint to get disease names
const getDiseaseNames = async (req, res) => {
  // SQLITE
  // db.all(`SELECT disease FROM ${reportTableName}`, [], (err, rows) => {
  //   if (err) {
  //     console.error(err.message);
  //   }

  //   const data = rows.map((row) => {
  //     const obj = {};
  //     Object.keys(row).forEach((key) => {
  //       obj[key] = row[key];
  //     });
  //     return obj;
  //   });
  //   res.status(200).json(data);
  // });
  // SUPABASE
  const { data, error } = await supabase
    .from(reportTableName)
    .select("disease");
  if (error) {
    console.error(error);
    res.status(500).send({
      message: "An error occurred while processing the request",
    });
    return;
  }
  res.status(200).json(data);
};

// Endpoint to return report data
const getReportData = async (req, res) => {
  // SQLITE
  // db.all(`SELECT * FROM ${reportTableName}`, [], (err, rows) => {
  //   if (err) {
  //     console.error(err.message);
  //   }

  //   // Transform the rows to objects
  //   const data = rows.map((row) => {
  //     const obj = {};
  //     Object.keys(row).forEach((key) => {
  //       obj[key] = row[key];
  //     });
  //     return obj;
  //   });
  //   res.status(200).json(data);
  // });

  // SUPABASE
  const { data, error } = await supabase.from(reportTableName).select("*");
  if (error) {
    console.error(error);
    res.status(500).send({
      message: "An error occurred while processing the request",
    });
    return;
  }
  res.status(200).json(data);
};

//Endpoint to return data for the analytics page
// Endpoint to return report data with pagination
const getReportAnalytics = async (req, res) => {
  const page = req.query.page || 1; // Get the page number from the request query, default to 1
  const pageSize = 10; // Number of records to return per page

  // Calculate the offset based on the page number and page size
  const offset = (page - 1) * pageSize;

  // Select table with pagination  SQLITE
  // db.all(
  //   `SELECT * FROM ${reportTableName} LIMIT ? OFFSET ?`,
  //   [pageSize, offset],
  //   (err, rows) => {
  //     if (err) {
  //       console.error(err.message);
  //       return res.status(500).json({ error: "Internal server error" });
  //     }

  //     // Transform the rows to objects
  //     const data = rows.map((row) => {
  //       const obj = {};
  //       Object.keys(row).forEach((key) => {
  //         obj[key] = row[key];
  //       });
  //       return obj;
  //     });

  //     res.json(data);
  //   }
  // );

  // SUPABASE
  const { data, error } = await supabase
    .from(reportTableName)
    .select("*")
    .range(offset, offset + pageSize - 1);

  if (error) {
    console.error(error);
    return res.status(500).json({ error: "Internal server error" });
  }

  res.status(200).json(data);
};

module.exports = {
  createStaffRecord,
  defaultResponse,
  generateExcel,
  getDiseaseNames,
  getReportAnalytics,
  getReportData,
  getStaffData,
  getStaffMemberByID,
  getStaffHistory,
  getStudentByAdmissionNumber,
  getStudentHistory,
  getStudentData,
  newStudents,
  staffFullEntry,
  staffQuickUpdate,
  studentFullEntry,
  studentQuickUpdate,
  updateReport,
  getStudentsGoingToHospital,
  updateStudentRecord,
  createStudentRecord,
};
